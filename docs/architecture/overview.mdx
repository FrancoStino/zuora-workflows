---
title: Architecture Overview
description: Understand the application's overall architecture and design patterns used
---

# Architecture Overview

Zuora Workflow Manager follows a clean service-oriented architecture with clear separation of responsibilities. This section provides an overview of how components interact with each other.

## General Architecture

The application follows the **Service-Oriented** (SOA) architecture with MVC (Model-View-Controller) pattern.

```mermaid
graph TB
    subgraph "Presentation Layer"
        A[Filament UI]
        B[API Endpoints]
        C[CLI Commands]
    end

    subgraph "Application Layer"
        D[Controllers]
        E[Jobs]
        F[Services]
    end

    subgraph "Domain Layer"
        G[Models]
        H[Business Logic]
    end

    subgraph "Infrastructure Layer"
        I[(Database)]
        J[Queue]
        K[Cache]
    end

    subgraph "External Services"
        L[Zuora REST API]
        M[Google OAuth]
    end

    A --> D
    B --> D
    C --> E
    D --> F
    E --> F
    F --> L
    F --> M
    F --> G
    G --> I
    E --> J
    F --> K

    L --> F
    M --> F

    G --> A
```

### Layer Description

| Layer | Responsibility | Components |
|-------|--------------|------------|
| **Presentation** | UI and API | Filament Resources, API Routes, CLI Commands |
| **Application** | Business logic and orchestration | Services, Jobs, Controllers |
| **Domain** | Domain entities and rules | Models, Form Requests, Policies |
| **Infrastructure** | Persistence and infrastructure | Database, Queue, Cache |
| **External** | External integrations | Zuora API, Google OAuth |

## Main Components

### 1. Filament UI Layer

Filament provides the admin panel for application management.

**Filament Resources:**
- `CustomerResource` - Customer management (CRUD)
- `WorkflowResource` - Workflow management and visualization
- `TaskResource` - Task management with advanced filters
- `UserResource` - User management
- `RoleResource` - Role and permission management

**Filament Pages:**
- Create/Edit forms for CRUD
- List tables with search and filters
- Relation managers for model relationships
- Custom pages for complex visualizations

### 2. Application Layer

#### Services

The Service Layer encapsulates business logic:

**Services Responsibilities:**

| Service | Responsibility | Key Methods |
|---------|--------------|-------------|
| **ZuoraService** | Communication with Zuora API | `listWorkflows()`, `getAccessToken()`, `downloadWorkflow()` |
| **WorkflowSyncService** | Workflow sync orchestration | `syncCustomerWorkflows()`, `syncWorkflowRecord()` |
| **OAuthService** | Google OAuth integration | `login()`, `callback()` |

#### Jobs

Jobs handle asynchronous processes:

```php
// app/Jobs/SyncCustomersJob.php

class SyncCustomersJob implements ShouldQueue
{
    public $tries = 3;           // Retry 3 times
    public $backoff = 60;         // 60 seconds between retry
    public $timeout = 300;         // 5 minute timeout

    public function __construct(
        public Customer $customer
    ) {}

    public function handle(): void
    {
        $service = app(WorkflowSyncService::class);
        $service->syncCustomerWorkflows($this->customer);
    }
}
```

**ResponsabilitÃ  Services:**

| Service | ResponsabilitÃ  | Metodi Chiave |
|---------|--------------|--------------|
| **ZuoraService** | Comunicazione con Zuora API | `listWorkflows()`, `getAccessToken()`, `downloadWorkflow()` |
| **WorkflowSyncService** | Orchestrazione sincronizzazione workflow | `syncCustomerWorkflows()`, `syncWorkflowRecord()` |
| **OAuthService** | Integrazione Google OAuth | `login()`, `callback()` |

#### Jobs

I Job gestiscono processi asincroni:

```php
// app/Jobs/SyncCustomersJob.php

class SyncCustomersJob implements ShouldQueue
{
    public $tries = 3;           // Retry 3 volte
    public $backoff = 60;         // 60 secondi tra retry
    public $timeout = 300;         // Timeout 5 minuti

    public function __construct(
        public Customer $customer
    ) {}

    public function handle(): void
    {
        $service = app(WorkflowSyncService::class);
        $service->syncCustomerWorkflows($this->customer);
    }
}
```

**Workflow Job Queue:**

```mermaid
sequenceDiagram
    participant U as User
    participant F as Filament UI
    participant Q as Queue
    participant J as SyncCustomersJob
    participant S as WorkflowSyncService
    participant Z as Zuora API
    participant DB as Database

    U->>F: Click "Sync Workflows"
    F->>Q: SyncCustomersJob::dispatch()
    Q->>J: Process job
    J->>S: syncCustomerWorkflows()
    S->>Z: Fetch workflows
    Z-->>S: Return workflows
    S->>DB: Save/update workflows
    S->>DB: Extract tasks
    J-->>Q: Job completed
    Q-->>F: Job finished
    F-->>U: Show success message
```

### 3. Domain Layer

#### Models

Eloquent models represent domain entities:

```mermaid
erDiagram
    CUSTOMER ||--o{ WORKFLOW : has
    WORKFLOW ||--o{ TASK : has
    CUSTOMER ||--o{ USER : manages
    USER ||--o{ ROLE : has
    ROLE ||--o{ PERMISSION : has
```

**Models:**

| Model | Table | Responsibility |
|-------|---------|--------------|
| **Customer** | `customers` | Zuora credentials, multi-tenancy |
| **Workflow** | `workflows` | Workflows synced from Zuora |
| **Task** | `tasks` | Tasks extracted from workflows |
| **User** | `users` | System users |
| **Setting** | `settings` | Application settings |

### 4. Infrastructure Layer

#### Database

MariaDB 11.4 manages data persistence:

```sql
-- Main tables
customers     â†’ Zuora credentials for customer
workflows      â†’ Synced workflows
tasks          â†’ Tasks extracted from workflows
users          â†’ System users
roles          â†’ Filament Shield roles
settings       â†’ Application settings
jobs           â†’ Queued jobs
failed_jobs    â†’ Failed jobs
```

**Database Relationships:**

```sql
-- Foreign Keys
workflows.customer_id â†’ customers.id (ON DELETE CASCADE)
tasks.workflow_id â†’ workflows.id (ON DELETE CASCADE)
```

#### Queue System

Laravel Queue manages asynchronous jobs:

**Supported Drivers:**
- `sync` - Immediate execution (no queue)
- `database` - Database persistence
- `redis` - High-performance with Redis

**Workflow Queue:**

```mermaid
graph LR
    A[Dispatch Job] --> B[Queue]
    B --> C[Worker]
    C --> D{Success?}
    D -->|SÃ¬| E[Mark Complete]
    D -->|No| F[Retry]
    F --> G{Max Tries?}
    G -->|No| B
    G -->|SÃ¬| H[Move to Failed Jobs]
```

#### Cache

Laravel Cache optimizes performance:

**Cache Drivers:**
- `array` - Per single request (development)
- `database` - Database persistence
- `redis` - High-performance (production)

**What is Cached:**
- OAuth token Zuora (1h TTL)
- Application config
- Route cache
- View cache

## Design Patterns Used

### 1. Service Layer Pattern

Services encapsulate business logic:

```php
// Service for complex logic
class WorkflowSyncService
{
    public function __construct(
        private ZuoraService $zuoraService
    ) {}

    public function syncCustomerWorkflows(Customer $customer): array
    {
        // Business logic here...
    }
}
```

**Benefits:**
- âœ… Separation of concerns
- âœ… Testability
- âœ… Reusability
- âœ… Dependency Injection

### 2. Repository Pattern (via Eloquent)

Models act as repositories:

```php
// Model as repository
$customer->workflows()->create($data);
$customer->workflows()->where('zuora_id', $id)->first();
$workflow->tasks()->where('state', 'pending')->get();
```

**Benefits:**
- âœ… Clean API for data access
- âœ… Fluent query builder
- âœ… Automatic relationships
- âœ… Lazy/Eager loading

### 3. Observer Pattern

Laravel events trigger automatic actions:

```php
// app/Models/Customer.php

protected static function booted(): void
{
    static::created(function (Customer $customer) {
        SyncCustomersJob::dispatch($customer);
    });
}
```

**Workflow Observer:**

```mermaid
sequenceDiagram
    participant A as App
    participant E as Event System
    participant O as Observer
    participant J as Job
    participant Q as Queue

    A->>E: Customer created
    E->>O: Trigger event
    O->>J: Create job
    J->>Q: Dispatch job
```

**Benefits:**
- âœ… Decoupling
- âœ… Automatic reactivity
- âœ… Logic separated from model

### 4. Strategy Pattern

Different queue drivers as strategies:

```php
// Configurable strategy
switch (config('queue.default')) {
    case 'sync':
        // Immediate execution
        break;
    case 'database':
        // Background processing
        break;
    case 'redis':
        // High-performance processing
        break;
}
```

**Benefits:**
- âœ… Configuration flexibility
- âœ… Driver swappability
- âœ… Environment-specific optimization

### 5. Factory Pattern

Laravel Service Container creates instances:

```php
// Automatic dependency injection
public function __construct(
    private ZuoraService $zuoraService
) {}

// Manual resolution
$service = app(ZuoraService::class);
```

**Benefits:**
- âœ… Singleton pattern
- âœ… Lazy loading
- âœ… Testability (mocking)

## Data Flow

### Workflow Synchronization Flow

```mermaid
sequenceDiagram
    participant U as User
    participant F as Filament UI
    participant C as Controller
    participant J as Job
    participant WS as WorkflowSyncService
    participant ZS as ZuoraService
    participant ZA as Zuora API
    participant DB as Database
    participant Q as Queue

    U->>F: Click "Sync Workflows"
    F->>C: Dispatch Job
    C->>Q: SyncCustomersJob::dispatch()
    Q->>J: Dequeue Job
    J->>WS: syncCustomerWorkflows()
    WS->>ZS: authenticate()
    ZS->>ZA: POST /oauth/token
    ZA-->>ZS: Return access_token
    ZS-->>WS: Return token
    WS->>ZS: listWorkflows()
    ZS->>ZA: GET /workflows
    ZA-->>ZS: Return workflows
    ZS-->>WS: Return data
    WS->>ZS: downloadWorkflow()
    ZS->>ZA: GET /workflows/{id}/export
    ZA-->>ZS: Return JSON
    ZS-->>WS: Return JSON
    WS->>DB: Create/Update workflows
    DB-->>WS: Saved
    WS->>DB: Extract & sync tasks
    DB-->>WS: Tasks synced
    WS-->>J: Return statistics
    J-->>Q: Mark complete
    Q-->>F: Notify completion
    F-->>U: Show success
```

### Task Extraction Flow

```mermaid
sequenceDiagram
    participant W as Workflow Model
    participant J as JSON Export
    participant T as Task Model
    participant DB as Database

    W->>J: syncTasksFromJson()
    J->>J: Parse JSON tasks
    loop For each task
        J->>T: updateOrCreate()
        T->>DB: Save/Update task
        DB-->>T: Saved
    end
    J->>T: Delete stale tasks
    T->>DB: DELETE WHERE NOT IN
    DB-->>J: Deleted
    J-->>W: Return count
```

## Security Architecture

### Authentication & Authorization

```mermaid
graph TB
    A[User Login] --> B{Auth Method}
    B -->|Credentials| C[Local Auth]
    B -->|OAuth| D[Google OAuth]
    C --> E[Session]
    D --> E
    E --> F[Filament Shield]
    F --> G{Role Check}
    G -->|Super Admin| H[Full Access]
    G -->|Admin| I[Manage Customers/Workflows]
    G -->|Viewer| J[Read Only]
    H --> K[Resource Access]
    I --> K
    J --> K
```

### Data Protection

**Encryption:**
- `client_secret` - Encrypted with EncryptedCast
- `APP_KEY` - Encryption key
- Sessions - Encrypted with Laravel

**RBAC:**
- Filament Shield for granular permissions
- Role-based access control
- Policy-based authorization

### API Security

```mermaid
sequenceDiagram
    participant C as Client
    participant A as API Middleware
    participant T as Token Guard
    participant R as Resource

    C->>A: Request with Bearer Token
    A->>T: Validate token
    T->>A: User ID
    A->>R: Check permissions
    R->>A: Access granted/denied
    A-->>C: Response
```

## Performance Architecture

### Optimization Layers

```mermaid
graph TB
    A[Request] --> B[Cache Layer]
    B -->|Miss| C[Application]
    B -->|Hit| D[Response]

    C --> E[Database Indexes]
    C --> F[Query Optimization]
    C --> G[Eager Loading]

    E --> H[Fast Queries]
    F --> H
    G --> H

    H --> I[Minimal Load]
    I --> D
```

**Caching Strategy:**
- OAuth tokens (1h TTL)
- Application config
- Route cache (production)
- View cache (production)

**Database Optimization:**
- Indexes on foreign keys
- Indexes on frequent queries
- Foreign key cascade operations

## Scalability Considerations

### Horizontal Scaling

```mermaid
graph LR
    A[Load Balancer] --> B[App Server 1]
    A --> C[App Server 2]
    A --> D[App Server N]

    B --> E[(Redis Queue)]
    C --> E
    D --> E

    B --> F[(MariaDB)]
    C --> F
    D --> F
```

**Horizontally scalable with:**
- Redis for distributed queue
- Database read replicas
- Shared cache (Redis)
- Sticky sessions if needed

### Vertical Scaling

**Optimizations:**
- Increase server resources
- Multiple queue workers
- Database connection pooling
- PHP OPcache

## Next Steps

<CardGroup cols={2}>
  <Card title="Service Layer" icon="cog" href="/architecture/service-layer">
    Details on main services
  </Card>
  <Card title="Data Model" icon="database" href="/architecture/data-model">
    Database schema and relationships
  </Card>
  <Card title="Design Patterns" icon="puzzle" href="/architecture/design-patterns">
    Design patterns used
  </Card>
  <Card title="Core Concepts" icon="lightbulb" href="/core-concepts/customer">
    Fundamental domain concepts
  </Card>
</CardGroup>

## Resources

- ðŸ“– [Laravel Architecture](https://laravel.com/docs/architecture-concepts)
- ðŸ“– [Design Patterns PHP](https://refactoring.guru/design-patterns/php)
- ðŸ“– [Service Layer Pattern](https://martinfowler.com/eaaCatalog/serviceLayer.html)

---

**Version**: 1.4.0 |
**Last Updated**: December 2025
